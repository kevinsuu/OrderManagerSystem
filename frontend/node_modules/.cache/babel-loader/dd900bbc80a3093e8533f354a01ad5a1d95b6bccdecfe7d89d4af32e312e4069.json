{"ast":null,"code":"import axios from 'axios';\nconst AUTH_SERVICE_URL = 'https://ordermanagersystem-auth-service.onrender.com';\n\n// 刷新 token 的函數\nexport const refreshToken = async () => {\n  try {\n    const refreshToken = localStorage.getItem('refreshToken');\n    if (!refreshToken) {\n      throw new Error('沒有可用的刷新令牌');\n    }\n    const response = await axios.post(`${AUTH_SERVICE_URL}/api/v1/auth/refresh`, {\n      refreshToken: refreshToken\n    }, {\n      headers: {\n        'Content-Type': 'application/json',\n        'Accept': '*/*'\n      },\n      withCredentials: false\n    });\n    if (response.data.token) {\n      localStorage.setItem('userToken', response.data.token);\n      if (response.data.refreshToken) {\n        localStorage.setItem('refreshToken', response.data.refreshToken);\n      }\n      return response.data.token;\n    } else {\n      throw new Error('刷新令牌失敗');\n    }\n  } catch (error) {\n    console.error('刷新令牌失敗:', error);\n    localStorage.removeItem('userToken');\n    localStorage.removeItem('refreshToken');\n    localStorage.removeItem('userData');\n    throw error;\n  }\n};\n\n// 建立一個帶有統一錯誤處理的 axios 實例\nexport const createAuthAxios = navigate => {\n  const instance = axios.create({\n    headers: {\n      'Content-Type': 'application/json',\n      'Accept': 'application/json'\n    },\n    withCredentials: false\n  });\n\n  // 是否正在刷新 token\n  let isRefreshing = false;\n  // 等待令牌刷新的請求隊列\n  let failedQueue = [];\n\n  // 處理隊列中的請求\n  const processQueue = (error, token = null) => {\n    failedQueue.forEach(prom => {\n      if (error) {\n        prom.reject(error);\n      } else {\n        prom.resolve(token);\n      }\n    });\n    failedQueue = [];\n  };\n\n  // 請求攔截器 - 添加令牌\n  instance.interceptors.request.use(config => {\n    const token = localStorage.getItem('userToken');\n    if (token) {\n      config.headers.Authorization = `Bearer ${token}`;\n    }\n    return config;\n  }, error => Promise.reject(error));\n\n  // 響應攔截器 - 處理令牌刷新\n  instance.interceptors.response.use(response => response, async error => {\n    var _error$response;\n    const originalRequest = error.config;\n\n    // 如果是 401 錯誤且不是刷新令牌的請求，且請求未重試過\n    if (((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.status) === 401 && !originalRequest._retry && !originalRequest.url.includes('/api/v1/auth/refresh')) {\n      if (isRefreshing) {\n        // 如果已經在刷新，將請求加入隊列\n        return new Promise((resolve, reject) => {\n          failedQueue.push({\n            resolve,\n            reject\n          });\n        }).then(token => {\n          originalRequest.headers.Authorization = `Bearer ${token}`;\n          return instance(originalRequest);\n        }).catch(err => Promise.reject(err));\n      }\n      originalRequest._retry = true;\n      isRefreshing = true;\n      try {\n        // 嘗試刷新令牌\n        const newToken = await refreshToken();\n        originalRequest.headers.Authorization = `Bearer ${newToken}`;\n\n        // 處理等待中的請求\n        processQueue(null, newToken);\n        return instance(originalRequest);\n      } catch (refreshError) {\n        // 刷新失敗，處理等待中的請求\n        processQueue(refreshError);\n\n        // 重定向到登入頁面\n        if (navigate) {\n          navigate('/login');\n        }\n        return Promise.reject(refreshError);\n      } finally {\n        isRefreshing = false;\n      }\n    }\n    return Promise.reject(error);\n  });\n  return instance;\n};","map":{"version":3,"names":["axios","AUTH_SERVICE_URL","refreshToken","localStorage","getItem","Error","response","post","headers","withCredentials","data","token","setItem","error","console","removeItem","createAuthAxios","navigate","instance","create","isRefreshing","failedQueue","processQueue","forEach","prom","reject","resolve","interceptors","request","use","config","Authorization","Promise","_error$response","originalRequest","status","_retry","url","includes","push","then","catch","err","newToken","refreshError"],"sources":["/Users/sumingkai/Documents/OrderManagerSystem/frontend/src/utils/auth.js"],"sourcesContent":["import axios from 'axios';\n\nconst AUTH_SERVICE_URL = 'https://ordermanagersystem-auth-service.onrender.com';\n\n// 刷新 token 的函數\nexport const refreshToken = async () => {\n    try {\n        const refreshToken = localStorage.getItem('refreshToken');\n        if (!refreshToken) {\n            throw new Error('沒有可用的刷新令牌');\n        }\n\n        const response = await axios.post(`${AUTH_SERVICE_URL}/api/v1/auth/refresh`, {\n            refreshToken: refreshToken\n        }, {\n            headers: {\n                'Content-Type': 'application/json',\n                'Accept': '*/*'\n            },\n            withCredentials: false\n        });\n\n        if (response.data.token) {\n            localStorage.setItem('userToken', response.data.token);\n            if (response.data.refreshToken) {\n                localStorage.setItem('refreshToken', response.data.refreshToken);\n            }\n            return response.data.token;\n        } else {\n            throw new Error('刷新令牌失敗');\n        }\n    } catch (error) {\n        console.error('刷新令牌失敗:', error);\n        localStorage.removeItem('userToken');\n        localStorage.removeItem('refreshToken');\n        localStorage.removeItem('userData');\n        throw error;\n    }\n};\n\n// 建立一個帶有統一錯誤處理的 axios 實例\nexport const createAuthAxios = (navigate) => {\n    const instance = axios.create({\n        headers: {\n            'Content-Type': 'application/json',\n            'Accept': 'application/json'\n        },\n        withCredentials: false\n    });\n\n    // 是否正在刷新 token\n    let isRefreshing = false;\n    // 等待令牌刷新的請求隊列\n    let failedQueue = [];\n\n    // 處理隊列中的請求\n    const processQueue = (error, token = null) => {\n        failedQueue.forEach(prom => {\n            if (error) {\n                prom.reject(error);\n            } else {\n                prom.resolve(token);\n            }\n        });\n        failedQueue = [];\n    };\n\n    // 請求攔截器 - 添加令牌\n    instance.interceptors.request.use(\n        (config) => {\n            const token = localStorage.getItem('userToken');\n            if (token) {\n                config.headers.Authorization = `Bearer ${token}`;\n            }\n            return config;\n        },\n        (error) => Promise.reject(error)\n    );\n\n    // 響應攔截器 - 處理令牌刷新\n    instance.interceptors.response.use(\n        (response) => response,\n        async (error) => {\n            const originalRequest = error.config;\n\n            // 如果是 401 錯誤且不是刷新令牌的請求，且請求未重試過\n            if (error.response?.status === 401\n                && !originalRequest._retry\n                && !originalRequest.url.includes('/api/v1/auth/refresh')) {\n\n                if (isRefreshing) {\n                    // 如果已經在刷新，將請求加入隊列\n                    return new Promise((resolve, reject) => {\n                        failedQueue.push({ resolve, reject });\n                    })\n                        .then(token => {\n                            originalRequest.headers.Authorization = `Bearer ${token}`;\n                            return instance(originalRequest);\n                        })\n                        .catch(err => Promise.reject(err));\n                }\n\n                originalRequest._retry = true;\n                isRefreshing = true;\n\n                try {\n                    // 嘗試刷新令牌\n                    const newToken = await refreshToken();\n                    originalRequest.headers.Authorization = `Bearer ${newToken}`;\n\n                    // 處理等待中的請求\n                    processQueue(null, newToken);\n                    return instance(originalRequest);\n                } catch (refreshError) {\n                    // 刷新失敗，處理等待中的請求\n                    processQueue(refreshError);\n\n                    // 重定向到登入頁面\n                    if (navigate) {\n                        navigate('/login');\n                    }\n                    return Promise.reject(refreshError);\n                } finally {\n                    isRefreshing = false;\n                }\n            }\n\n            return Promise.reject(error);\n        }\n    );\n\n    return instance;\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}